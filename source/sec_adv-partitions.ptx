<?xml version="1.0" encoding="UTF-8"?>
<section xmlns:xi="http://www.w3.org/2001/XInclude" xml:id="sec_adv-partitions">
  <title>Counting Partitions</title>
  <introduction>
    <p>
      Partitions are one of the core ideas in discrete mathematics.  Recall that a <term>partition</term> of a set <m>S</m> is a collection of mutually disjoint subsets of <m>S</m> whose union is all of <m>S</m>.  In other words, every element of <m>S</m> belongs to exactly one of the subsets of the partition.  We call the subsets that make up the partition <term>blocks</term> or <term>parts</term> of the partition.
    </p>
    <p>
      The integers can be naturally partitioned into evens and odds.  In fact, this is just a specific case of partitioning the integers by their reminder when divided by a fixed constant; another example is that every integer has remainder 0, 1, or 2 when divided by 3.
    </p>
    <p>
      Finite sets also have natural partitions: the set of all 4-bit strings can be partitioned according to weight: <me>\B^4_0 \cup \B^4_1 \cup \B^4_2 \cup \B^4_3 \cup \B^4_4 = \B^4</me>.
      Using the sum principle on these disjoint sets leads directly to the identity
      <m>\binom{4}{0} + \binom{4}{1} + \binom{4}{2} + \binom{4}{3} + \binom{4}{4} = 2^4</m>
      (and of course the 4 can be replaced with any <m>n</m> here).
    </p>

    <p>
      In fact, many of the identities we established in <xref ref="sec_basic-proofs" /> using a combinatorial proof work precisely because we can count a set of outcomes all at once and also by counting the size of each block in a particular partition.  For example, in <xref ref="act_derangement-binom" /> we proved that
      <me>\binom{n}{0} d_{0} + \binom{n}{1} d_{1} + \binom{n}{2} d_{2} + \ldots + \binom{n}{n} d_{n} = n!</me>
      by partitioning the <m>n!</m> permutations of <m>[n]</m> into blocks according to how many are fixed in position while the rest are deranged.  
    </p>

    <p>
      Even the formula for binomial coefficients, <m>\binom{n}{k} = \frac{n!}{(n-k)!k!}</m>, comes from partitioning the <m>k</m>-permutations of <m>[n]</m> into blocks according to which subset of <m>[n]</m> is selected (and then <m>\binom{n}{k}</m> is precisely the number of blocks).
    </p>

    <p>
      In this section we will abstract this fundamental idea of partitions by one level.  Instead of using particular partitions to answer counting questions, we will ask counting questions about partitions themselves.  As we will see, this helps us solve yet more counting questions. 
    </p>

    <p>
      In <xref ref="sec_basic-quotient"/> we considered some ways to distribute items to recipients.  Most basic counting formulas can be thought of as counting the number of ways to distribute either distinct or identical items to distinct recipients.  For example, distributing <m>k</m> distinct items to <m>n</m> distinct recipients can be done in <m>n^k</m> ways, if recipients can receive any number of items, or <m>P(n,k)</m> ways if recipients can receive at most one item.  If the items are identical, the corresponding number of ways to distribute them are <m>\mchoose{n}{k}</m> and <m>\binom{n}{k}</m>.
    </p>

    <p>
      What if the recipients are not distinct?  Say we wish to distribute <m>k</m> books (either distinct or identical) to <m>n</m> identical boxes.  This is a perfectly natural extension, but we will see the answer is not.  First, let's get a feel for what this might look like for some small values of <m>k</m> and <m>n</m>.
    </p>

    <activity xml:id="act_stirlingintro">
      <introduction>
        <p>
          Suppose you have <m>3</m> distinct books you want to put into <m>5</m> identical boxes.
        </p>
      </introduction>
      <task>
        <statement>
          <p>
            How many ways can you do this if each box can have at most one book?
          </p>
        </statement>
      </task>
      <task>
        <statement>
          <p>
            How many ways can you do this if any box can have any number of books?  You might want to consider three cases: one, two, or three boxes are used.  Assume we do not care about the order in which the books are placed inside boxes.
          </p>
        </statement>
      </task>
      <task>
        <statement>
          <p>
            Describe the outcomes we are counting in abstract mathematical terms.  What sort of mathematical objects are we counting?
          </p>
        </statement>
      </task>
    </activity>

    <activity xml:id="act_intpartintro">
      <introduction>
        <p>
          Suppose you have <m>3</m> identical books you want to put in <m>5</m> identical boxes.
        </p>
      </introduction>
      <task>
        <statement>
          <p>
            How many ways can you do this if each box can have at most one book?
          </p>
        </statement>
      </task>
      <task>
        <statement>
          <p>
            How many ways can you do this if any box can have any number of books?  Again, you should consider three cases.
          </p>
        </statement>
      </task>
      <task>
        <statement>
          <p>
            What mathematical objects are we counting here?
          </p>
        </statement>
      </task>
    </activity>
  </introduction>

  <subsection>
    <title>Partitions of Sets</title>

    <p>
      We would like to count the number of ways to partition a set.
    </p>

    <definition xml:id="def-stirling">
      <statement>
        <p>
          Denote by <m>S(k,n)</m> the number of partitions of <m>[k]</m> into exactly <m>n</m> subsets.  We call <m>S(k,n)</m> a <term>Stirling number (of the second kind)</term>.
        </p>
      </statement>
    </definition>

    <p>
      Note that we write <m>S(k,n)</m> instead of <m>S(n,k)</m> here because we try to use <m>k</m> for the number of elements being distributed and <m>n</m> for the number of recipients.  When other books use <m>S(n,k)</m>, they mean the number of partitions of <m>[n]</m> into exactly <m>k</m> blocks.  This is the same definition as we give, but with our renamed variables the formulas we get might look different.
    </p>

    <p>
      For example, consider how to partition <m>[3]</m> into exactly two sets:
      <me>
        \{1,2\}, \{3\} \qquad \qquad \{1,3\},\{2\} \qquad \qquad \{2,3\},\{1\}
      </me>
      and that is all, so <m>S(3,2) = 3</m>.  We do not care about the order the elements appear in each block, nor the order in which the blocks appear.  Thus we see the Stirling numbers count the number of ways to distribute <m>k</m> distinct items to <m>n</m> identical recipients so that each recipient gets at least one item.
    </p>

    <activity xml:id="act_stirlingcomputations">
      <introduction>
        <p>
          Get to know the Stirling numbers by finding some.  List the set of partitions and count them.
        </p>
      </introduction>

      <task>
        <statement>
          <p>
            Find <m>S(3,1)</m>, <m>S(4,1)</m> and <m>S(k,1)</m>.
          </p>
        </statement>
      </task>

      <task>
        <statement>
          <p>
            Compute <m>S(2,2)</m>, <m>S(3,2)</m> and <m>S(4,2)</m>.  Find a formula for <m>S(k,2)</m> and prove it is correct.
          </p>
        </statement>
      </task>

      <task>
        <statement>
          <p>
            Compute <m>S(3,3)</m>, and <m>S(4,3)</m>.
          </p>
        </statement>
      </task>

      <task>
        <statement>
          <p>
            Find formulas and give proofs for <m>S(k,k)</m> and
            <m>S(k,k - 1)</m>.
          </p>
        </statement>
        <hint>
          <p>
            What are the possible sizes of parts?
          </p>
        </hint>
        <solution>
          <p>
            If a partition has <m>k-1</m> parts, then one part has two elements, so once we choose those two elements from the <m>k</m> elements, we are done.  Therefore <m>S(k,k-1) = \binom{k}{2}</m>.
          </p>
        </solution>
      </task>
    </activity>



    <p>
      We can arrange the Stirling numbers into a triangle (called <term>Stirling's second triangle</term>).  The first five rows are shown below.  The entries are indexed differently than in Pascal's triangle: the top 1 represents <m>S(1,1)</m>, so for example, <m>S(5,2) = 15</m>.
    </p>

    <sidebyside width="50%">
      <tabular>
        <row>
          <cell></cell>
          <cell></cell>
          <cell></cell>
          <cell></cell>
          <cell>1</cell>
          <cell></cell>
          <cell></cell>
          <cell></cell>
          <cell></cell>
        </row>
        <row>
          <cell/><cell/><cell/>
          <cell>1</cell>
          <cell></cell>
          <cell>1</cell>
          <cell/><cell/><cell/>
        </row>
        <row>
          <cell/><cell/>
          <cell>1</cell>
          <cell></cell>
          <cell>3</cell>
          <cell></cell>
          <cell>1</cell>
          <cell/><cell/>
        </row>
        <row>
          <cell/>
          <cell>1</cell>
          <cell></cell>
          <cell>7</cell>
          <cell></cell>
          <cell>6</cell>
          <cell></cell>
          <cell>1</cell>
          <cell/>
        </row>
        <row>
          <cell>1</cell>
          <cell></cell>
          <cell>15</cell>
          <cell></cell>
          <cell>25</cell>
          <cell></cell>
          <cell>10</cell>
          <cell></cell>
          <cell>1</cell>
        </row>
      </tabular>
    </sidebyside>

    <p>
      How were these found?  Sure, we could have written out all 25 of the partitions of <m>[5]</m> into exactly <m>3</m> blocks, but we didn't.  Could there be some way to get 25 from the entries above it?  That is, what is the recurrence relation among the Stirling numbers?
    </p>

    <activity>
      <!-- <task> -->
        <statement>
          <p>
            Write down (if you haven't already) all 6 partitions of <m>[4]</m> into <m>3</m> blocks.  Break these into two cases by where 4 is: is 4 in solitary confinement (in a singleton set) or does he have a cellmate?
          </p>
        </statement>
      <!-- </task>
      <task> -->
        <!-- <statement>
          <p>
            How could you take the <m>S(4,2) = 7</m> partitions of <m>[4]</m> into 2 sets and the <m>S(4,3) = 6</m> partitions of <m>[4]</m> into 3 sets and form all the <m>S(5,3) = 25</m> partitions of <m>[5]</m> into <m>3</m> sets?
          </p>
        </statement> -->
      <!-- </task> -->
    </activity>

    <p>
      Now that you have some experience with listing the <m>S(4,3)</m> partitions of <m>[4]</m>, the next example will help us to generalize.
    </p>

    <example>
      <statement>
        <p>
          Let's see how to take <m>S(4,2) = 7</m> and <m>S(4,3) = 6</m> to compute <m>S(5,3) = 25</m>.  First, here are the partitions of <m>[4]</m> into 2 blocks (group A) or 3 blocks (group B), side by side:
        </p>
        
        <sidebyside widths="50% 30%" valign="top">
          <p>
            Group A: 
            <md>
              <mrow>\{1\}, ~ \{2,3,4\}\qquad \amp \{1,2\}, ~ \{3, 4\}</mrow>
              <mrow>\{2\}, ~ \{1,3,4\}\qquad \amp \{1,3\}, ~ \{2, 4\}</mrow>
              <mrow>\{3\}, ~ \{1,2,4\} \qquad \amp \{2,3\}, ~ \{1, 4\}</mrow>
              <mrow>\{4\}, ~ \{1,2,3\} \qquad\amp </mrow>
            </md>
          </p>
          
          <p>
            Group B: 
            <md>
              <mrow>\{2\}, ~ \{1,2\}, ~ \{4\}</mrow>
              <mrow>\{2\}, ~ \{1,3\}, ~ \{4\}</mrow>
              <mrow>\{2\}, ~ \{1,4\}, ~ \{3\}</mrow>
              <mrow>\{1\}, ~ \{2,3\}, ~ \{4\}</mrow>
              <mrow>\{1\}, ~ \{2,4\}, ~ \{3\}</mrow>
              <mrow>\{1\}, ~ \{3,4\}, ~ \{2\}</mrow>
            </md>
          </p>
        </sidebyside>
        
        <p>
          (Notice the <m>\binom{4}{2}</m> ways of listing the middle column in group B.)
        </p>
        
        <p>
          Now, to list the <m>S(5,3)</m> partitions of <m>[5]</m> into <m>3</m> parts, we need to add 5 somewhere.  We can either
          <ol label="a.">
            <li>
              <p>
                Let 5 be a singleton block, along with any of the partitions from group A; or
              </p>
            </li>
            <li>
              <p>
                Let 5 join any of the blocks in any of the partitions of group B.  
              </p>
            </li>
          </ol>
          The second option can be accomplished in <m>3\cdot 6</m> ways.  Thus <m>S(5,3) = 7 + 3\cdot 6</m>.
        </p>
      </statement>
    </example>

    <activity xml:id="secondstirlingrecurrence" category="essential and interesting">
        <statement>
          <p>
            Now generalize.  In a partition of the set <m>[k]</m>, the number <m>k</m> is either in a block by itself, or it is not.  Find a two variable recurrence for <m>S(k,n)</m>, valid for <m>k</m> and <m>n</m> larger than one.
          </p>
        </statement>
        <hint>
          <p>
            The number of partitions of <m>[k]</m> into <m>n</m> parts in which <m>k</m> is not in a block relates to the number of partitions of <m>k-1</m> into some number of blocks in a way that involves <m>n</m>. With this in mind, review how you proved Pascal's (recurrence) equation.
          </p>
        </hint>

        <solution>
          <p>
            The number of partitions of <m>[k]</m> into <m>n</m> parts in which
            <m>k</m> is in a block with other elements of <m>[k]</m> is equal
            <m>n</m> times the number of partitions of <m>[k-1]</m> into
            <m>n</m> blocks, because <m>k</m> could be in any of the <m>n</m>
            parts, and since it is in a block with other elements of
            <m>[k-1]</m>, removing it leaves a partition of <m>[k-1]</m> into
            <m>n</m> blocks. The number of partitions of <m>[k]</m> into
            <m>n</m> blocks in which <m>k</m> is in a block by itself is the
            number of partitions of <m>[k]</m> into <m>n-1</m> blocks, because
            you can get any such partition by deleting the block containing
            <m>k</m> from a partition of <m>[k]</m> in which <m>k</m> is in a
            block by itself. Thus <m>S(k,n) = S(k-1,n-1) + nS(k-1,n)</m>.
          </p>
        </solution>
    </activity>


    <exploration category="interesting">
      <statement>
        <p>
          Find a recurrence for the Lah numbers <m>L(k,n)</m> similar to the one in <xref ref="secondstirlingrecurrence"/>.
        </p>
      </statement>
      <hint>
        <p>
      To see how many broken permutations of a <m>k</m> element set into <m>n</m> parts do not have <m>k</m> is a part by itself, ask yourself how many broken permutations of <m>[7]</m> result from adding 7 to the one of the two permutations in the broken permutation <m>\{14, 2356\}</m>.
        </p>
      </hint>
      <solution>
        <p>
          <m>L(k,n)</m> is the number of broken permutations of a
          <m>k</m>-element set into <m>n</m> parts. Either <m>k</m> is in an ordered block with other numbers, or it is in a block by itself. If it is with other elements, it can go after any of the <m>k-1</m> other
          elements, or it can go at the beginning of any of the <m>n</m> blocks. If
          it is by itself, deleting it gives a broken permutation of a <m>k-1</m>-element
          set into <m>n-1</m> blocks. Thus <m>L(k,n)=L(k-1,n-1) + (n+k-1)L(k-1,n)</m>.
        </p>
      </solution>
    </exploration>


    <exploration xml:id="sandwiches">
      <statement>
          <p>
            Extend Stirling's triangle enough to allow you to answer the following question and answer it. (Don't fill in the rows all the way; the work becomes quite tedious if you do. Only fill in what you need to answer this question.) A caterer is preparing three bag lunches for hikers. The caterer has nine different sandwiches. In how many ways can these nine sandwiches be distributed into three identical lunch bags so that each bag gets at least one?
          </p>
        </statement>
        <solution>
          <p>
            We need <m>S(9,3)</m>. Thus we need to extend our table for four
            more rows, but only out to the column labeled 3. These rows are,
          </p>
          <sidebyside width="50%">
            <tabular>
              <row>
                <cell right="minor">6</cell>
                <cell>1</cell>
                <cell>31</cell>
                <cell>90</cell>
                <cell><ellipsis /></cell>
              </row>
              <row>
                <cell right="minor">7</cell>
                <cell>1</cell>
                <cell>63</cell>
                <cell>101</cell>
                <cell><ellipsis /></cell>
              </row>
              <row>
                <cell right="minor">8</cell>
                <cell>1</cell>
                <cell>127</cell>
                <cell>966</cell>
                <cell><ellipsis /></cell>
              </row>
              <row>
                <cell right="minor">9</cell>
                <cell>1</cell>
                <cell>255</cell>
                <cell>3025</cell>
                <cell><ellipsis /></cell>
              </row>
            </tabular>
          </sidebyside>
          <p>
            Thus there are 3025 ways to distribute the sandwiches
            into the lunch bags.
          </p>
        </solution>
      </exploration>

      <p>
        We have often thought of counting problems as asking about how many functions there are from a <m>k</m>-elements set to an <m>n</m>-element set.  The answer to this question is <m>n^k</m> for all functions and <m>P(n,k)</m> for injective functions.  What about surjective functions?  There is a reason we haven't asked this question yet, but now we can at least get an expression for the number of surjections in terms of Stirling numbers.
      </p>


    <exploration category="motivation">
      <statement>
        <p>
          Given a function <m>f</m> from a <m>k</m>-element set <m>K</m> to an <m>n</m>-element set, we can define a partition of <m>K</m> by putting <m>x</m> and <m>y</m> in the same block of the partition if and only if <m>f(x)=f(y)</m>. How many blocks does the partition have if <m>f</m> is surjective? How is the number of functions from a <m>k</m>-element set <em>onto</em> an <m>n</m>-element set related to a Stirling number? Be as precise in your answer as you can.<idx><h>function</h><h>surjective!and Stirling Numbers</h></idx><idx><h>surjective function</h><h>counting</h></idx>
        </p>
      </statement>
      <hint>
        <p>
      You can think of a function as assigning values to the blocks of its
      partition. If you permute the values assigned to the blocks, do you always
      change the function?
        </p>
      </hint>
      <solution>
        <p>
          If <m>f</m> is onto, the number of blocks of the partition is <m>n</m>. The number of onto functions from a <m>k</m>-element set onto an <m>n</m>-element set is <m>S(k,n)n!</m>, because we have a one-to-one function from the blocks to the <m>n</m>-element set.
        </p>
      </solution>
    </exploration>

    <p>
      We do not have an explicit formula for either the number of surjections or for <m>S(k,n)</m> yet, but note that if we could find either, we would now have both.  We will see one approach to this in <xref ref="sec_adv-pie"/>.
    </p>



        <exploration xml:id="Stirlingfalling" category="essential">
          <statement>
            <p>
              Each function from a <m>k</m>-element set <m>K</m> to an <m>n</m>-element set <m>N</m> is a function from <m>K</m> onto <em>some</em> subset of <m>N</m>. If <m>J</m> is a subset of <m>N</m> of size <m>j</m>, you know how to compute the number of functions that map onto <m>J</m> in terms of Stirling numbers. Suppose you add the number of functions mapping onto <m>J</m> over all possible subsets <m>J</m> of <m>N</m>. What simple value should this sum equal? Write the equation this gives you.
            </p>
          </statement>
          <hint>
            <p>
          When you add the number of functions mapping onto <m>J</m> over all possible subsets <m>J</m> of <m>N</m>, what is the set of functions whose size you are computing?
            </p>
          </hint>
          <solution>
            <p>
              The sum should equal the number of functions, <m>n^k</m>. Thus
              we get <m>\sum_{j=0}^n \binom{n}{j}S(k,j)j! = n^k</m>. By using the fact
              that <m>\binom{n}{j}= P(n,j)/j!</m>, this may be rewritten as
              <m>\sum_{j=0}^n P(n,j)S(k,j) = n^k.</m>
            </p>
          </solution>
        </exploration>

        <exploration category="motivation">
          <statement>
            <p>
              In how many ways can the sandwiches of <xref ref="sandwiches"/> be placed into three distinct bags so that each bag gets at least one?
            </p>
          </statement>
          <solution>
            <p>
              <m>S(9,3)\cdot3!= 55,980</m>.
            </p>
          </solution>
        </exploration>



    <p>
      We will further investigate Stirling numbers in <xref ref="sec_adv-stirling"/>.  Before leaving set partitions though, notice that we have not looked at the number of ways to partition a set into <em>any</em> number of blocks.
    </p>

    <definition xml:id="def-bell">
      <idx><h>Bell Number</h></idx><idx><h>partitions of a set</h><h>number of</h></idx>
      <statement>
        <p>
          The total number of partitions of a <m>k</m>-element set is denoted by <m>B_k</m> and is called the <m>k</m>-th <term>Bell number</term>.
        </p>
      </statement>
    </definition>
    
    <example>
      <p>
        There are five partitions of <m>[3]</m>:
        <md>
          <mrow>\{1\}, \{2\},\{3\}</mrow>
          <mrow>\{1,2\},\{3\} \qquad \{1,3\},\{2\} \qquad \{1\}, \{2,3\}</mrow>
          <mrow>\{1,2,3\}</mrow>.
        </md>
        Note that <m>B_3 = S(3,1)+S(3,2)+S(3,3) = 1 + 3 + 1</m>.
      </p>
    </example>

    <activity xml:id="BellNumberIntro" category="essential for this or the next section">
      <task>
        <statement>
          <p>
            Why is <m>B_k = \sum_{n=1}^{k} S(k,n)</m>, but <m>n^k \ne \sum_{n=1}^k S(k,n)n!</m>?  Why is this a meaningful question?
          </p>
        </statement>
        <hint>
          <p>
            As to why this is a reasonable question, think of distributing <m>k</m> items to <m>n</m> recipients.  All four expressions count the number of ways to do this under different restrictions.
          </p>
        </hint>
      </task>
      <task>
        <statement>
          <p>
            Find a recurrence that expresses <m>B_k</m> in terms of <m>B_n</m> for
            <m>n\lt  k</m> and prove your formula correct in as many ways as you can.
          </p>
        </statement>
        <hint>
          <p>
        Here it is helpful to think about what happens if you delete the entire block containing <m>k</m> rather than thinking about whether <m>k</m> is in a block by itself or not.
          </p>
        </hint>
        <solution>
          <p>
            If we delete the block containing <m>k</m>, we get a partition of
            a subset of <m>[k-1]</m>. Thus <m>B_k</m> is the sum over all subsets of
            <m>[k-1]</m> of the number of partitions of that subset. This gives us
            <m>B_k= \sum_{n=0}^{k-1}\binom{k-1}{n}B_n</m>.
          </p>

          <p>
            Alternatively, we can show by the same sort of argument that
            <m>S(k,n)=\sum_{i=0}^{k-1} \binom{k-1}{i}S(i,n-1)</m> and then use the fact
            that <m>B_k =\sum_{n=0}^k S(k,n)</m> to get the recurrence for <m>B_k</m>.
          </p>
        </solution>
      </task>

      <task>
        <statement>
          <p>
            Find <m>B_k</m> for <m>k=1,2,4,5,6</m>.
          </p>
        </statement>
        <solution>
            <p>
                <me>
                    B_4 =\binom{3}{0}B_0 +\binom{3}{1}B_1 +\binom{3}{2}B_2 +
                    \binom{3}{3}B_3=1 +3+3\cdot2 +5=15
                </me>
                <me>
                    B_5 = \sum_{n=0}^4 \binom{4}{n}B_n = 1 +4+6\cdot2 +4\cdot5 + 15=52
                </me>
                <me>
                    B_6 = \sum_{n=0}^5 \binom{5}{n}B_n =1+5 +10\cdot2 +10\cdot 5
                    +5\cdot 15 +52=203
                </me>
            </p>
        </solution>
      </task>
    </activity>

    <p>
      The Bell numbers are interesting in their own right, and we will look at them more in <xref ref="sec_adv-bell"/>.
    </p>

</subsection>




<subsection>
  <title>Partitions of Integers</title>
    <p>
      In <xref ref="compositionagian"/>, we counted the <em>compositions</em> of an integer <m>n</m>, by counting the number of solutions to the equation <m>x_1 + x_2 + \cdots + x_k = n</m> where each <m>x_i</m> is a positive integer.  Put another way, we asked how many <em>lists</em> of <m>k</m> positive integers have sum <m>n</m>.  The order in which we listed the sum mattered.  What if it didn't?
    </p>
    <p>
      A multiset of positive integers that add to <m>n</m> is called a <term>partition</term><idx><h>partition of an integer</h></idx> of <m>n</m>. Thus the partitions of 3 are 1+1+1, 1+2 (which is the same as 2+1) and 3. The number of partitions of <m>k</m> is denoted by <m>p(k)</m>; in computing the partitions of 3 we showed that <m>p(3) = 3</m>. It is traditional to use Greek letters like <m>\lambda</m> to stand for partitions; we might write <m>\lambda = 1,1,1</m>, <m>\gamma= 2,1</m> and <m>\tau = 3</m> to stand for the three partitions we just described. We also write <m>\lambda = 1^3</m> as a shorthand for <m>\lambda = 1,1,1</m>, and we write <m>\lambda \dashv 3</m> as a shorthand for <q><m>\lambda</m> is a partition of three.</q>
    </p>

    <example>
      There are 5 partitions of 4 (so <m>p(4) = 5</m>).  They are <m>4=1+1+1+1</m>, <m>4=2+1+1</m>, <m>4=2+1</m>, <m>4=3+1</m>, and <m>4=4</m>.
    </example>


    <activity category="motivation">
      <statement>
        <p>
          Write out all partitions of of 5, to compute <m>p(5)</m>.
        </p>
      </statement>
      <solution>
        <p>
           <m>5=1+1+1+1+1</m>, <m>5=2+1+1+1</m>, <m>5=2+2+1</m>, <m>5=3+1+1</m>, <m>5=3+2</m>,
          <m>5=4+1</m>, <m>5=5</m>, so <m>P(5)=7</m>.
        </p>
      </solution>
    </activity>


    <p>
      A <term>partition of the integer <m>k</m> into <m>n</m> parts</term><idx><h>partition of an integer</h><h>into <m>n</m> parts</h></idx> is a multiset of <m>n</m> positive integers that add to <m>k</m>. We use <m>p_n(k)</m> to denote the number of partitions of <m>k</m> into <m>n</m> parts. Thus <m>p_n(k)</m> is the number of ways to distribute <m>k</m> identical objects to <m>n</m> identical recipients so that each gets at least one.
    </p>
    
    <example>
      <p>
        Here are the partitions of 7 into two parts: <m>6+1</m>, <m>5+2</m>, <m>4+3</m>.  Thus <m>p_2(7) = 3</m>.
      </p>
    </example>

    <activity category="motivation">
      <statement>
        <p>
          Find <m>p_3(6)</m> by finding all partitions of 6 into 3 parts. What does this say about the number of ways to put six identical apples into three identical bags so that each bag has at least one apple?
        </p>
      </statement>
      <solution>
        <p>
          <m>6=4+1+1</m>, <m>6=3+2+1</m>, <m>6=2+2+2</m>, so <m>P(6,3)=3</m>. This says
          there are three ways to put six identical apples into three identical
          bags so that each bag gets at least one apple.
        </p>
      </solution>
    </activity>


    <exploration category="motivation">
        <statement>
          <p>
            How many solutions are there in the positive integers to the
            equation <m>x_1+x_2+x_3 =7</m> with <m>x_1\ge x_2\ge x_3</m>?
          </p>
        </statement>
        <solution>
          <p>
            This problem is asking for <m>p_3(7)</m> and suggests an
            organized way to go about finding it: list the partitions starting
            with the largest part and work down. <m>7=5+1+1</m>, <m>7=4+2+1</m>,
            <m>7=3+3+1</m>, <m>7=3+2+2</m>, and if we have three numbers that add to seven,
            one must be larger than two, so there are four such solutions.
          </p>
        </solution>
    </exploration>
    
    <exploration>
        <statement>
          <p>
            Explain the relationship between partitions of <m>k</m> into <m>n</m> parts and lists <m>x_1,x_2,\ldots,x_n</m> of positive integers with <m>x_1 + x_2 + \cdots + x_n = k</m> and <m>x_1\ge x_2\ge\ldots \ge x_n</m>. Such a representation of a partition is called a <term>decreasing list</term><idx><h>partition of an integer</h><h>decreasing list</h></idx> representation of the partition.
          </p>
        </statement>
        <solution>
          <p>
            There is a bijection between partitions of <m>k</m> into <m>n</m> parts and lists, in nonincreasing order, of <m>n</m> positive integers that add to <m>k</m>, because each multiset of numbers that adds to <m>k</m> can be listed in nonincreasing order in exactly one way.
          </p>
        </solution>
    </exploration>

    <exploration>
      <statement>
        <p>
          Show that <m>p_n(k)</m> is at least <m>\frac{1}{n!}\binom{k-1}{n-1}</m>.
        </p>
      </statement>
      <hint>
        <p>
          How many compositions are there of <m>k</m> into <m>n</m> parts? What is the maximum number of compositions that could correspond to a given partition of <m>k</m> into <m>n</m> parts?
        </p>
      </hint>
      <solution>
        <p>
          The number of compositions of <m>k</m> into <m>n</m> parts is <m>\binom{k-1}{n-1}</m>. We can divide the compositions into blocks, where two compositions are in the same block if and only if one is a rearrangement of the other. Then the blocks correspond bijectively to partitions of <m>k</m> into <m>n</m> parts. However we cannot compute the number of blocks by dividing by the number of compositions per block since the number of compositions per block ranges from <m>1</m> to <m>n!</m>.  But then if we divide the number of compositions by <m>n!</m> we will get a number less than the number of blocks because <m>n!</m> times the number of blocks would be, by the sum principle, greater than the number of partitions.
        </p>
      </solution>
  </exploration>


    <exploration category="motivation">
        <statement>
          <p>
            Describe the relationship between partitions of <m>k</m> and lists of vectors <m>(x_1,x_2,\ldots,x_n)</m> such that <m>x_1+2x_2+\ldots kx_k = k</m>.  Such a representation of a partition is called a <term>type vector</term> representation of a partition, and it is typical to leave the trailing zeros out of such a representation; for example <m>(2,1)</m> stands for the same partition as <m>(2,1,0,0)</m>. What is the decreasing list representation for this partition, and what number does it partition?<idx><h>partition of an integer</h><h>type vector</h></idx><idx><h>type vector for a partition of an integer</h></idx>
          </p>
        </statement>
        <solution>
          <p>
            The type vector of a partition of <m>k</m> is a way of
            representing the multiplicity function of the multiset of integers
            that adds to <m>k</m>. Thus there is a bijection between type vectors and
            partitions.
          </p>
        </solution>
    </exploration>
    
    <exploration>
        <statement>
          <p>
            How does the number of partitions of <m>k</m> relate to the number of partitions of <m>k+1</m> whose smallest part is one?
          </p>
        </statement>
        <hint>
          <p>
        How can you start with a partition of <m>k</m> and make it into a new partition of <m>k+1</m> that is guaranteed to have a part of size one, even if the original partition didn't?
          </p>
        </hint>
        <solution>
          <p>
            They are equal, because if we take two different partitions
            of <m>k-1</m> and increase the multiplicity of 1 in each (by one), they are
            still different; also if we take two different partitions of <m>k</m> that
            have parts of size one, and decrease the multiplicity of 1 in each (by
            one), they are still different.
          </p>
        </solution>
    </exploration>

    <p>
      When we write a partition as <m>\lambda = \lambda_1,\lambda_2,\ldots,\lambda_n</m>, it is customary to write the list of <m>\lambda_i</m>s as a decreasing list. When we have a type vector <m>(t_1,t_2,\ldots,t_m)</m> for a partition, we write either <m>\lambda = 1^{t_1}2^{t_2}\cdots m^{t_m}</m> or <m>\lambda = m^{t_m}(m-1)^{t_{m-1}}\cdots 2^{t_2}1^{t_1}</m>. Henceforth we will use the second of these. When we write <m>\lambda=\lambda_1^{i_1}\lambda_2^{i_2}\cdots\lambda_n^{i_n}</m>, we will assume that <m>\lambda_i>\lambda_i+1</m>.
    </p>


    <p>
      The decreasing list representation of partitions leads us to a handy way to visualize partitions. Given a decreasing list <m>(\lambda_1,\lambda_2,\ldots \lambda_n)</m>, we draw a figure made up of rows of dots that has <m>\lambda_1</m> equally spaced dots in the first row, <m>\lambda_2</m> equally spaced dots in the second row, starting out right below the beginning of the first row and so on. Equivalently, instead of dots, we may use identical squares, drawn so that a square touches each one to its immediate right or immediately below it along an edge. See <xref ref="FerrersYoung">Figure</xref> for examples.<idx><h>Ferrers diagram</h></idx><idx><h>Young diagram</h></idx><idx><h>partition of an integer</h><h>Ferrers diagram</h></idx><idx><h>partition of an integer</h><h>Young diagram</h></idx><idx><h>diagram</h><h>of a partition!Ferrers</h></idx><idx><h>diagram</h><h>of a partition!Young</h></idx> The figure we draw with dots is called the <term>Ferrers diagram</term> of the partition; sometimes the figure with squares is also called a Ferrers diagram; sometimes it is called a <term>Young diagram</term>. At this stage it is irrelevant which name we choose and which kind of figure we draw; in more advanced work the squares are handy because we can put things like numbers or variables into them.  From now on we will use squares and call the diagrams Young diagrams.
    </p>

    <figure xml:id="FerrersYoung" >
      <caption>The Ferrers
      and Young diagrams of the partition
      (5,3,3,2)</caption>
      <image width="45%" source="images/FerrersYoung" />
    </figure>

    <exploration>
      <statement>
        <p>
          Just for practice, draw all the Young diagrams for the partitions of 4 and 5.
        </p>
      </statement>
    </exploration>



    <p>
      With the binomial coefficients, with Stirling numbers of the second kind, and with the Lah numbers, we were able to find a recurrence by asking what happens to our subset, partition, or broken permutation of a set <m>S</m> of numbers if we remove the largest element of <m>S</m>. Thus it is natural to look for a recurrence to count the number of partitions of <m>k</m> into <m>n</m> parts by doing something similar. Unfortunately, since we are counting distributions in which all the objects are identical, there is no way for us to identify a largest element. However if we think geometrically, we can ask what we could remove from a Young diagram to get a Young diagram.
    </p>
    <p>
      Two natural ways to get a partition of a smaller integer from a partition of <m>n</m> would be to remove the top row of the Young diagram of the partition and to remove the left column of the Young diagram of the partition. These two operations correspond to removing the largest part from the partition and to subtracting 1 from each part of the partition respectively. Even though these have some sort of geometric symmetry, the two operations are not symmetric with respect to the number of parts. Thus one might be much more useful than the other for finding a recurrence for the number of partitions of <m>k</m> into <m>n</m> parts.
    </p>

    

    <activity xml:id="numberpartitionrecurrence" category="essential for this or the next section, and interesting">
      <!-- TODO: clean up or make example.  or give an example first. -->
        <introduction>
            <p>
        In this problem we will study the two operations and see which one seems more useful for getting a recurrence for <m>p_n(k)</m>.
            </p>
        </introduction>
      <task>
        <statement>
          <p>
            How many parts does the remaining partition have when we remove the largest part (more precisely, we reduce its multiplicity by one) from a partition of <m>k</m> into <m>n</m> parts?  What can you say about the number of parts of the remaining partition if we remove one from each part?
          </p>
        </statement>
        <hint>
          <p>
            These two operations do rather different things to the number of parts, and you can describe exactly what only one of the operations does. Think about the Young diagram.
          </p>
        </hint>
        <solution>
          <p>
            Reducing the multiplicity of the largest part by one reduces the number of parts by one. Removing 1 from each part reduces the number of parts by the multiplicity of the smallest part, so it strictly reduces the number of parts, perhaps even to one.
          </p>
        </solution>
      </task>

      <task>
        <statement>
          <p>
            If we remove the largest part from a partition, what can we say about the integer that is being partitioned by the remaining parts of the partition? If we remove one from each part of a partition of <m>k</m> into <m>n</m> parts, what integer is being partitioned by the remaining parts? (Another way to describe this is that we remove the first column from the Young diagram of the partition.)
          </p>
        </statement>
        <hint>
          <p>
            Think about the Young diagram. In only one of the two cases can you give an exact answer to the question.
          </p>
        </hint>
        <solution>
          <p>
            If we remove the largest part, the integer being partitioned is <m>k</m> minus the largest part. Thus it is a number less than <m>k</m> and at least <m>n-1</m>. If we remove one from each part of the partition, the integer being partitioned is <m>k-n</m>.
          </p>
        </solution>
      </task>
      <task>
        <statement>
          <p>
            The last two questions are designed to get you thinking about how we can get a bijection between the set of partitions of <m>k</m> into <m>n</m> parts and some other set of partitions that are partitions of a smaller number.  These questions describe two different strategies for getting that set of partitions of a smaller number or of smaller numbers.  Each strategy leads to a bijection between partitions of <m>k</m> into <m>n</m> parts and a set of partitions of a smaller number or numbers.  For each strategy, use the answers to the last two questions to find and describe this set of partitions into a smaller number and a bijection between partitions of <m>k</m> into <m>n</m> parts and partitions of the smaller integer or integers into appropriate numbers of parts. (In one case the set of partitions and bijection are relatively straightforward to describe and in the other case not so easy.)
          </p>
        </statement>
        <hint>
          <p>
            Here the harder part requires that, after removal, you consider a range of possible numbers being partitioned and that you give an upper bound on the part size. However it lets you describe the number of parts exactly.
          </p>
        </hint>
        <solution>
          <p>
            Removing the largest part of a partition of <m>k</m> into <m>n</m> parts gives us a bijection between partitions of <m>k</m> into <m>n</m> parts and and partitions of numbers <m>k'</m> between <m>n-1</m> and <m>k-1</m> into <m>n-1</m> parts of size at most <m>k-k'</m>. (Removing the largest part gives us such a partition, and adjoining a part of size <m>k-k'</m> to such a partition gives us a partition of <m>k</m> with <m>n</m> parts.)
          </p>

          <p>
            Removing one from each part of a partition of <m>k</m> into <m>n</m> parts gives us a bijection between partitions of <m>k</m> into <m>n</m> parts and and partitions <m>k-n</m> into <m>n</m> or fewer parts. (Removing one from each part of a partition of <m>k</m> into <m>n</m> parts gives us such a partition, and, given such a partition, we get a partition of <m>k</m> into <m>n</m> parts by adding one to each part and then creating enough parts of size 1 to have <m>n</m> parts.)
          </p>
        </solution>
      </task>
      <task>
        <statement>
          <p>
            Find a recurrence (which need not have just two terms on the right hand side) that describes how to compute <m>p_n(k)</m> in terms of the number of partitions of smaller integers into a smaller number of parts.
          </p>
        </statement>
        <hint>
          <p>
            One of the two sets of partitions of smaller numbers from the previous part is more amenable to finding a recurrence than the other. The resulting recurrence does not have just two terms though.
          </p>
        </hint>

        <solution>
          <p>
            The second bijection is to the set of partitions of <m>k-n</m> into <m>n</m> or fewer parts, and this makes the second bijection sound easier to work with. We get <m>p_n(k)=\sum_{i=1}^n p_i(k-n)</m>. The proof is the bijection we already described; in particular a partition of <m>k-n</m> into <m>i</m> parts corresponds to the partition of <m>k</m> we get by adding one to each of the <m>i</m> parts and then creating <m>n-i</m> parts of size one.
          </p>
        </solution>
      </task>
      <task>
        <statement>
          <p>
            What is <m>p_1(k)</m> for a positive integer <m>k</m>?
          </p>
        </statement>
        <solution>
          <p>
            <m>p_1(k)=1</m>.
          </p>
        </solution>
      </task>
      <task>
        <statement>
          <p>
            What is <m>p_k(k)</m> for a positive integer <m>k</m>?
          </p>
        </statement>
        <solution>
          <p>
            <m>p_k(k)=1</m>.
          </p>
        </solution>
      </task>
      <task>
        <statement>
          <p>
            Use your recurrence to compute a table with the values of <m>p_n(k)</m> for values of <m>k</m> between 1 and 7.
          </p>
        </statement>
        <solution>
            <sidebyside>
                <tabular>
                    <row bottom="minor">
                        <cell><m>k\backslash n</m></cell>
                        <cell>1</cell>
                        <cell>2</cell>
                        <cell>3</cell>
                        <cell>4</cell>
                        <cell>5</cell>
                        <cell>6</cell>
                        <cell>7</cell>
                    </row>
                    <row>
                        <cell>1</cell>
                        <cell>1</cell>
                        <cell>0</cell>
                        <cell>0</cell>
                        <cell>0</cell>
                        <cell>0</cell>
                        <cell>0</cell>
                        <cell>0</cell>
                    </row>
                    <row>
                        <cell>2</cell>
                        <cell>1</cell>
                        <cell>1</cell>
                        <cell>0</cell>
                        <cell>0</cell>
                        <cell>0</cell>
                        <cell>0</cell>
                        <cell>0</cell>
                    </row>
                    <row>
                        <cell>3</cell>
                        <cell>1</cell>
                        <cell>1</cell>
                        <cell>1</cell>
                        <cell>0</cell>
                        <cell>0</cell>
                        <cell>0</cell>
                        <cell>0</cell>
                    </row>
                    <row>
                        <cell>4</cell>
                        <cell>1</cell>
                        <cell>2</cell>
                        <cell>1</cell>
                        <cell>1</cell>
                        <cell>0</cell>
                        <cell>0</cell>
                        <cell>0</cell>
                    </row>
                    <row>
                        <cell>5</cell>
                        <cell>1</cell>
                        <cell>2</cell>
                        <cell>2</cell>
                        <cell>1</cell>
                        <cell>1</cell>
                        <cell>0</cell>
                        <cell>0</cell>
                    </row>
                    <row>
                        <cell>6</cell>
                        <cell>1</cell>
                        <cell>3</cell>
                        <cell>3</cell>
                        <cell>2</cell>
                        <cell>1</cell>
                        <cell>1</cell>
                        <cell>0</cell>
                    </row>
                    <row>
                        <cell>7</cell>
                        <cell>1</cell>
                        <cell>3</cell>
                        <cell>4</cell>
                        <cell>3</cell>
                        <cell>2</cell>
                        <cell>1</cell>
                        <cell>1</cell>
                    </row>
                </tabular>
            </sidebyside>
        </solution>
      </task>
      <task>
        <statement>
          <p>
            What would you want to fill into row 0 and column 0 of your table in order to make it consistent with your recurrence.  What does this say <m>p_0(0)</m> should be?  We usually define a sum with no terms in it to be zero. Is that consistent with the way the recurrence says we should define <m>p_0(0)</m>?
          </p>
        </statement>
        <hint>
          <p>
            If there is a sum equal to zero, there may very well be a partition of zero.
          </p>
        </hint>
        <solution>
          <p>
            We would want to have <m>p_0(0)=1</m> and <m>p_0(k)=p_n(0)=0</m> for positive integer <m>k</m> or <m>n</m>. Since the sum of the empty multiset of positive integers is zero, this gives us one partition of the number zero, namely the empty multiset of positive integers.
          </p>
        </solution>
      </task>
    </activity>

    <p>
      It is remarkable that there is no known formula for <m>p_n(k)</m>, nor is there one for <m>p(k)</m>. We have seen some ways to compute values of <m>p_n(k)</m>.  In <xref ref="sec_adv-linearparts"/> we will see more methods to compute values and find properties of these numbers even without ever knowing a formula for them.
    </p>


  </subsection>
</section>
