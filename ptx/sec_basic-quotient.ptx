<?xml version="1.0" encoding="UTF-8"?>
<section xmlns:xi="http://www.w3.org/2001/XInclude" xml:id="sec_basic-quotient">
  <title>Counting with Equivalence</title>

<introduction>
  <!-- Here we will discuss the relationship between combinations and permutations from an advanced mathematical perspective: we are counting equivalence classes.  We will then consider some other examples of this and some non-examples (why you cannot always do this). -->

<p>
  So far we have been able to solve our counting problems simply by use of the sum and product principles, together with the fact that the number of <m>k</m>-element subsets of an <m>n</m>-element set is <m>\binom{n}{k}</m> (the values of which can be found in Pascal's triangle). This means that we have always <em>built up</em> the set of outcomes by combining smaller sets of outcomes combined in various ways.
</p>

<p>
  It is often useful to go the other way.  We could purposely over count the number of outcomes, but in a way that we can recover the correct set.
</p>
</introduction>

<subsection xml:id="subsec-quotient">
  <title>The Quotient Principle</title>

  <p>
    In <xref ref="act-binomformula"/>, you proved the algebraic formula <m>\binom{n}{k} = \frac{n!}{(n-k)!k!}</m>.  However, this was done rather indirectly.  First you proved the identity <m>P(n,k) = \binom{n}{k}k!</m>, then wrote <m>P(n,k) = \frac{n!}{(n-k)!}</m>, and finally solved for <m>\binom{n}{k}</m>.
  </p>

  <p>
    This approach has the advantage of illustrating the connection between combinations and permutations, but the combinatorial argument that both sides of the identity are equal asked you to count the number of <em>permutations</em> in two ways.  It is instructive to think of this equation in terms of <em>combinations</em> instead.  Let's start with a concrete example.
  </p>

  <activity>
    <introduction>
      <p>
        Let's count the number of subsets of <m>\{a,b,c,d,e\}</m> of size 3.  Of course we already know the answer should be <m>\binom{5}{3}</m>, which we can see in Pascal's triangle is equal to 10.  What might you try if you didn't already know this?
      </p>
    </introduction>
    <task>
      <statement>
        <p>
          You might first guess that the answer is <m>5\cdot 4 \cdot 3</m> since there are 5 choices for which element you put in your subset first, then  4 choices for the next element, and 3 choices for the last element.  Write down all 60 of the outcomes you get by counting the <q>subsets</q> this way.<fn>This might seem like a lot of busy work, but your efforts will be rewarded.</fn>
        </p>
      </statement>
      <solution>
        <table xml:id="tab_permsof3" >
          <title>The <m>3</m>-element permutations of <m>\{a,b,c,d,e\}</m> organized
              by which <m>3</m>-element set they permute.</title>
          <tabular>
            <row>
              <cell><m>abc</m></cell>
              <cell><m>acb</m></cell>
              <cell><m>bac</m></cell>
              <cell><m>bca</m></cell>
              <cell><m>cab</m></cell>
              <cell><m>cba</m></cell>
            </row>
            <row>
              <cell><m>abd</m></cell>
              <cell><m>adb</m></cell>
              <cell><m>bad</m></cell>
              <cell><m>bda</m></cell>
              <cell><m>dab</m></cell>
              <cell><m>dba</m></cell>
            </row>
            <row>
              <cell><m>abe</m></cell>
              <cell><m>aeb</m></cell>
              <cell><m>bae</m></cell>
              <cell><m>bea</m></cell>
              <cell><m>eab</m></cell>
              <cell><m>eba</m></cell>
            </row>
            <row>
              <cell><m>acd</m></cell>
              <cell><m>adc</m></cell>
              <cell><m>cad</m></cell>
              <cell><m>cda</m></cell>
              <cell><m>dac</m></cell>
              <cell><m>dca</m></cell>
            </row>
            <row>
              <cell><m>ace</m></cell>
              <cell><m>aec</m></cell>
              <cell><m>cae</m></cell>
              <cell><m>cea</m></cell>
              <cell><m>eac</m></cell>
              <cell><m>eca</m></cell>
            </row>
            <row>
              <cell><m>ade</m></cell>
              <cell><m>aed</m></cell>
              <cell><m>dae</m></cell>
              <cell><m>dea</m></cell>
              <cell><m>ead</m></cell>
              <cell><m>eda</m></cell>
            </row>
            <row>
              <cell><m>bcd</m></cell>
              <cell><m>bdc</m></cell>
              <cell><m>cbd</m></cell>
              <cell><m>cdb</m></cell>
              <cell><m>dbc</m></cell>
              <cell><m>dcb</m></cell>
            </row>
            <row>
              <cell><m>bce</m></cell>
              <cell><m>bec</m></cell>
              <cell><m>cbe</m></cell>
              <cell><m>ceb</m></cell>
              <cell><m>ebc</m></cell>
              <cell><m>ecb</m></cell>
            </row>
            <row>
              <cell><m>bde</m></cell>
              <cell><m>bed</m></cell>
              <cell><m>dbe</m></cell>
              <cell><m>deb</m></cell>
              <cell><m>ebd</m></cell>
              <cell><m>edb</m></cell>
            </row>
            <row>
              <cell><m>cde</m></cell>
              <cell><m>ced</m></cell>
              <cell><m>dce</m></cell>
              <cell><m>dec</m></cell>
              <cell><m>ecd</m></cell>
              <cell><m>edc</m></cell>
            </row>
          </tabular>
        </table>
      </solution>
    </task>
    <task>
      <statement>
        <p>
          One of the subsets we are actually interested in is <m>\{a,c,d\}</m>.  How many of the outcomes you listed above correspond to this set?  How many outcomes correspond to the set <m>\{c,d,e\}</m>?
        </p>
      </statement>
    </task>
    <task>
      <statement>
        <p>
          Explain why every subset corresponds to the same number of permutations.  Then use this to count the total number of subsets correctly.
        </p>
      </statement>
    </task>
  </activity>

  <p>
    Let's look carefully at what we did above.  We had a set of permutations (all 60 of the 3-permutations of the set <m>\{a,b,c,d,e\}</m>).  Then we noticed that some of these permutations corresponded the the same subset.  Saying that these permutations were related like this feels like defining a equivalence relation.
  </p>

  <!-- TODO: should define equivalence relation somewhere or at least give a reference to make this more friendly -->

  <activity>
    <introduction>
      <p>
        Refer back to your list of 60 3-permutations of <m>\{a,b,c,d,e\}</m>.
      </p>
    </introduction>
    <task>
      <statement>
        <p>
          Define an <term>equivalence relation</term> on the permutations you listed so that permutations that <q>correspond</q> to the same subset are equivalent.  That is, give a rule that specifies when two permutations are <q>equivalent</q>.
        </p>
      </statement>
      <hint>
        <p>
          One rule of this type would be, two permutations are equivalent if they start with the same letter.  This is not the one you want though.
        </p>
      </hint>
    </task>
    <task>
      <statement>
        <p>
          In any set <m>S</m>, if you have an equivalence relation <m>\sim</m>, you can <term>partition</term> <m>S</m> into <term>equivalence classes</term>: sets of elements that are equivalent under <m>\sim</m> (i.e., sets of the form <m>\{x \in S \st x \sim a\} </m> for a particular element <m>a</m>).
        </p>
        <p>
          Write out the equivalence classes generated by the equivalence relation you gave above.  Explain why these all have the same size.  How many equivalence classes do you have (and how does this relate to the fact that they all have the same size)?
        </p>
      </statement>
    </task>
    <task>
      <statement>
        <p>
          Find a bijection between the set of equivalence classes and the set of subsets of <m>\{a,b,c,d,e\}</m>.  Why is this important?
        </p>
      </statement>
      <hint>
        <p>
          You might think about the usual way you would write a subset.  Essentially what this question is asking is for you to pick a representative for each equivalence class.
        </p>
      </hint>
    </task>
  </activity>

  <!-- TODO: make more friendly: -->

  <p>
    This suggests a general approach to solving a counting problem.  Say we want to count the number of elements in a set <m>S</m>.  Suppose we can count the size of some set <m>T</m>, perhaps containing many more elements than we are actually interested in counting.  Then define an equivalence relation <m>\sim</m> on <m>T</m> so that there is a bijection between <m>S</m> and the set of equivalence classes <m>T/\sim</m>.  Then if we know the size of <m>T/\sim</m>, we have the size of <m>S</m>.
  </p>

  <p>
    Look at the notation <m>T/\sim</m> that we used to denote the set of equivalence classes of <m>T</m> under <m>\sim</m>.  This set is sometimes called the <term>quotient set</term> or <term>quotient space</term> of <m>T</m> by <m>\sim</m>.  This is a good name, as you are dividing up a set into parts.  It is also a good name because sometimes we can conclude
    <me>
      |T/\sim| = |T|/|A|
    </me>
    where <m>A</m> is one of the equivalence classes under <m>\sim</m>.  When can you do this?
  </p>

  <p>
    Note this is exactly what we did when we counted subsets: we divided the number of permutations by the number of permutations equivalent to each other.  That worked precisely because <em>all the equivalence classes had the same size</em>!
  </p>

  <p>
    This justifies the <term>quotient principle</term> we now state.
  </p>

  <assemblage xml:id="assemblage-quotientprinciple">
    <title>The Quotient Principle</title>
    <p>
      If we partition a set of size <m>p</m> into <m>q</m> blocks, each of size <m>r</m>, then <m>q = p/r</m>.
    </p>
  </assemblage>

  <p>
    Like the product principle, the quotient principle is really just a statement about how division works.  Here are a few examples of how you can use it in counting.  In each of the following activities, make sure you can say exactly how the quotient principle could be used.
  </p>

  <exploration xml:id="roundtable" category="essential">
    <statement>
      <p>
        In how many ways may <m>n</m> people sit around a round
        table? (Assume
        that when people are sitting around a round table, all that really matters is who is to each person's right. For example, if we can get one arrangement of people around the table from another by having everyone get up and move to the right one place and sit back down, we get an equivalent arrangement of people. Notice that you can get a list from a seating arrangement by marking a place at the table, and then listing the people at the table, starting at that place and moving around to the right.) There are at least two different ways of doing this problem. Try to find them both, especially the one that uses the quotient principle.
      </p>
    </statement>
    <hint>
      <p>
        The problem suggests that you think about how to get a list from a seating arrangement. Could every list of n distinct people come from a seating chart? How many lists of n distinct people are there? How many lists could we get from a given seating chart by taking different starting places?
      </p>
    </hint>
    <hint>
      <p>
        For a different way of doing the problem, suppose that you have chosen one person, say the first one in a list of the people in alphabetical order by name. Now seat that person. Does it matter where they sit? In how many ways can you seat the remaining people? Does it matter where the second person in alphabetical order sits?
      </p>
    </hint>
    <solution>
      <p>
        The total number of ways to list how the <m>n</m> people sit around the table is <m>n!</m>. However, two lists are the same if we get one from the other by shifting everyone right the same number of places. This divides the set of lists up into sets of <m>n</m> mutually equivalent lists. The number <m>m</m> of such sets is the number of seating arrangements. However by the product principle, <m>mn=n!</m>, because we have partitioned up the set of <m>n!</m> lists into <m>m</m> sets of size <m>n</m>. Therefore <m>m=(n-1)!</m> A second solution may be obtained by choosing one of the <m>n</m> people and letting this person sit anywhere. Since all that matters is who is to the right of each person, it doesn't matter where this person sits. Once this person is seated, let everybody else sit down. If they sit down first in one order clockwise around the table and then in some other order, the person to the right of somebody has changed. Thus there are <m>(n-1)!</m> ways (the number of ways to seat everybody else) to seat the people around the table.
      </p>
    </solution>
  </exploration>

  <exploration xml:id="necklace" category="essential and interesting">
    <statement>
      <p>
        In how many ways may we string <m>n</m> distinct beads on a necklace
        without a clasp? (Perhaps we make the necklace by stringing the beads
        on a string, and then carefully gluing the two ends of the string
        together so that the joint can't be seen. Assume someone can pick up the necklace, move it around in space and put it back down, giving an
        apparently different way of stringing the beads that is
        equivalent to the first.)
      </p>
    </statement>
    <hint>
      <p>
        How could we get a list of beads from a necklace?
      </p>
    </hint>
    <hint>
      <p>
        When we cut the necklace and string it out on a table, there are <m>2n</m> lists of beads we could get. Why is it <m>2n</m> rather than <m>n</m>?
      </p>
    </hint>
    <solution>
      <p>
        There are <m>n!</m> permutations (lists, sequences) of the beads.  By gluing the ends together we get <m>n!</m> necklaces, but many of these have the same design as each other.  The question is, for a given design, how many of the necklaces formed from the <m>n!</m> permutations have that design?
      </p>
      <p>
        We can partition the permutations according to which necklace designs they create. Two permutations are in the same block if we get one either by circularly permuting the other or by reversing the other (this corresponds to flipping the necklace over in space). Thus each necklace corresponds to <m>2n</m> permutations so by the quotient principle we have <m>n!/2n=(n-1)!/2</m> ways to string <m>n</m> distinct beads on a necklace.
      </p>
    </solution>
  </exploration>

  <exploration xml:id="tennispairings2" category="interesting">
      <introduction>
          <p>
      We first gave this problem as <xref ref="tennispairings1"/>. Now we have several ways to approach the problem. A tennis club has <m>2n</m> members. We want to pair up the members by twos for singles matches.
          </p>
      </introduction>
    <task>
      <statement>
        <p>
          In how many ways may we pair up all the members of the club?
          Give at least two solutions different from the one you gave in   <xref ref="tennispairings1"/>.
          (You may not have done <xref ref="tennispairings1"/>. In that case, see if you can find three solutions.)
        </p>
      </statement>
      <hint>
          <p>
              You might first choose the pairs of people. You might also choose to make a list of all the people and then take them by twos from the list.
          </p>
      </hint>
      <solution>
          <p>
            Choose people in pairs. There are <m>\binom{2n}{2}</m> ways to choose one pair, <m>\binom{2n-2}{2}</m> ways to choose a second pair, and once <m>k</m> pairs have been chosen, there are <m>\binom{2n-2k}{2}</m> ways to choose the next pair.
            The number of <em>lists</em> of pairs we get in this way is <m>\prod_{i=0}^{n-1} \binom{2n-2i}{2}= \frac{(2n)!}{2^i}</m>.
            However each way of pairing people gets listed <m>n!</m> times since we see all possible length <m>n</m> lists of pairs.
            Therefore the number of actual pairings is <me>\frac{(2n)!}{2^n n!} = \frac{2n!}{2n\cdot2n-2\cdot2n-4\cdot \cdots\cdot 2} =  \prod_{i=0}^{n-1} 2n-2i-1.</me>
            Notice how this combinatorial solution gives the formula that we found algebraically in <xref ref="tennispairings1"/>, which then turns out to be algebraically equivalent to the formula we first saw in the solution to <xref ref="tennispairings1"/>.
          </p>

          <p>
            For yet another solution, we can list the <m>2n</m> members in <m>(2n)!</m> ways. Then
            we can take the first two as a tennis pair, the next two, and so on. There
            are <m>n!</m> ways that a given set of tennis pairings could be arranged, and
            each of the <m>n</m> pairs could appear in 2 ways, so the tennis pairings partition the set of all permutations of the <m>2n</m> members into blocks of size <m>n!2^n</m>. Thus we have <m>\frac{(2n)!}{n!2^n}</m> tennis pairings once again.
          </p>
      </solution>
    </task>

    <task>
        <statement>
        <p>
          Suppose that in addition to specifying who plays whom, for each
            pairing we say who serves first.  Now in how many ways may we
            specify our pairs? Try to find as many solutions as you can.
        </p>
      </statement>
     <hint>
         <p>You might first choose ordered pairs of people, and have the first person in each pair serve first. You might also choose to make a list of all the people and then take them by twos from the list in order.</p>
     </hint>
    <solution>
      <p>
        Choose people in ordered pairs.  The first person in an ordered pair serves first.  There are <m>2n(2n-1)</m> ways to choose one pair, <m>(2n-2)(2n-3)</m> ways to choose a second pair, and once <m>k</m> pairs have been chosen, there are <m>(2n-2k)(2n-2k-1)</m> ways to choose the next pair.  The number of <em>lists</em> of pairs we get in this way is <m>\prod_{i=0}^{n-1} (2n-2i)(2n-2i-1) = (2n)!</m>.
        However, each way of pairing people gets listed <m>n!</m> times since we see all possible length <m>n</m> lists of pairs.  Therefore the number of actual pairings is <m>\frac{(2n)!}{n!} = (2n)^{\underline{n}}</m>.
      </p>

      <p>
        For yet another solution, we can list the <m>2n</m> members in <m>(2n)!</m> ways. Then we can take the first two as a tennis pair, with the first person serving first, the next two, and so on. There are <m>n!</m> ways that a given set of tennis pairings could be arranged, so the tennis pairings partition the set of all permutations of the <m>2n</m> members into blocks of size <m>n!</m>. Thus we have <m>\frac{(2n)!}{n!}</m> tennis pairings once again.
      </p>
    </solution>
  </task>
  </exploration>

<!-- Activity 45 -->
  <exploration xml:id="twocolorsofbeads" category="essential">
    <statement>
      <p>
        In how many ways may we attach two identical red beads
        and two identical blue beads to the corners of a square (with one bead
        per corner) free
        to move around in (three-dimensional) space?
      </p>
    </statement>
    <hint>
        <p>
            It might be helpful to just draw some pictures of the possible configurations. There aren't that many.
        </p>
    </hint>
    <solution>
      <p>
        Two ways; either the red beads are side-by-side or diagonally
        opposite. If we think about partitioning lists of 2 <m>R</m>s and 2 <m>B</m>s so that
        two are in the same block if we get one from the other by moving the square,
        we get two blocks, <m>\{RRBB, BRRB, BBRR, RBBR\}</m> and <m>\{RBRB, BRBR\}</m>.
      </p>
    </solution>
  </exploration>

  <example>
    <statement>
      <p>
        We have used the quotient principle to explain the formula <m>\binom{n}{k} = \frac{n!}{(n-k)!k!}</m> by thinking of this as <m>\binom{n}{k} = \frac{P(n,k)}{k!}</m>.  What if we don't involve <m>P(n,k)</m> at all?
      </p>

      <p>
        Describe a set of outcomes that has size <m>n!</m> that can be partitioned into blocks of size <m>(n-k)!k!</m> so that each block corresponds to something <m>\binom{n}{k}</m> counts.
      </p>
    </statement>
    <!-- <hint>
      <p>
        You might try the next problem first to get an idea.
      </p>
    </hint>
    <hint>
      <p>
        One thing that <m>\binom{n}{k}</m> counts is all bit strings of length <m>n</m> and weight <m>k</m>.  What if instead of bit strings, we wanted all strings made up out of some number of distinct symbols that come in two types?  How can you make this be counted by <m>n!</m>?
      </p>
    </hint> -->
    <solution>
      <p>
        Suppose you have <m>k</m> red balls and <m>n-k</m> blue balls.  Each ball has a different number printed on it.  Thus there are <m>n!</m> different ways to arrange the <m>n</m> balls in a line.  But what if we only care about the color pattern the balls make (perhaps the numbers have been printed in invisible ink and have now vanished).  We can arrange these permutations of all <m>n</m> balls into blocks, where two permutations are in the same block if and only if they have the same sequence of colors (RRBRB<ellipsis />).  There are <m>(n-k)!k!</m> permutations in each block, since the red balls can be arranged in <m>k!</m> ways and the blue balls can be arranged in <m>(n-k)!</m> ways.
      </p>

      <p>
        All this says that the number of two-color patterns of length <m>n</m> including <m>k</m> red balls is <m>\frac{n!}{(n-k)!k!}</m>.  But of course the answer is also <m>\binom{n}{k}</m> because of the <m>n</m> positions, we must choose <m>k</m> positions to put the identical red balls.
      </p>
    </solution>
  </example>

  <exploration>
    <statement>
      <p>
        How many anagrams of the word <q>anagram</q> are there? (An anagram is a rearrangement of <em>all</em> of the letters of a word.)
      </p>
    </statement>
    <hint>
      <p>
        A much easier question would be, how many anagrams of the word <q>anbgrcm</q>?  Then use the quotient principle.
      </p>
    </hint>
    <solution>
      <p>
        Using the quotient principle, you can treat each <q>a</q> as distinct to list all <m>7!</m> arrangements.  But then group arrangements if they have their a's in the same positions: there are <m>3!</m> permutations in each block.  So there are <m>\frac{7!}{3!}</m> anagrams.
      </p>

      <p>
        Another approach is to first pick three of the seven positions for the a's.  This can be done in <m>\binom{7}{3}</m> ways.  Then you must permute the remaining 4 letters in the remaining 4 spots, in <m>4!</m> ways.  This give <m>\binom{7}{3}4!</m> anagrams.
      </p>
    </solution>
  </exploration>

</subsection>

<subsection xml:id="subsec-ordermatters">
  <title>When does Order Matter?</title>

  <p>
    One way to distinguish combinations from permutations is by asking whether <q>order matters</q>.  Both <m>\binom{n}{k}</m> and <m>P(n,k)</m> count the number of ways to select <m>k</m> objects from <m>n</m> objects without repeats, but you use the combination <m>\binom{n}{k}</m> when <q>order doesn't matter</q> and the permutation <m>P(n,k)</m> when <q>order matters</q>.  Despite the presence of the scare quotes, this is not a false statement, but we must understand what we mean when we say <q>order matters</q>.
  </p>

  <activity>
    <introduction>
      <p>
        Each counting question below asks for two answers.  Decide which answer is a combination and which is a permutation, and why that makes sense.
      </p>
    </introduction>
    <task>
      <statement>
        <p>
          An ice-cream shop offers 31 flavors.  How many 3-scoop ice-cream cones are possible, assuming each scoop must be a different flavor?  How many 3-scoop milkshakes are possible, assuming each scoop must be a different flavor?
        </p>
      </statement>
      <hint>
        <p>
          This is not intended to be a trick question.  In fact, this example would be a good one for thinking about how permutations and combinations are related in general.
        </p>
      </hint>
    </task>
    <task>
      <statement>
        <p>
          How many 5-digit numbers are there with distinct, non-zero digits for which the digits must be increasing?  How many are there for which the digits can come in any order?
        </p>
      </statement>
      <hint>
        <p>
          The point of this question is to push back against your conception of what <q>order matters</q> means.  Since you know the answers must be <m>\binom{9}{5}</m> or <m>P(9,5)</m>, you should be able to answer correctly by deciding which set is bigger.
        </p>
      </hint>
    </task>
    <task>
      <statement>
        <p>
          How many injective functions <m>f:[k] \to [n]</m> are there all   together?  How many injective functions <m>f:[k] \to [n]</m> are there that are (strictly) increasing?
        </p>
      </statement>
      <hint>
        <p>
          You might as well assume that <m>k \le n</m> (otherwise the answers would both be 0).  If you are stuck, write out some examples of each using two-line notation for the functions.  What decisions do you need to make?
        </p>
      </hint>
    </task>
  </activity>

  <exploration>
    <statement>
      <p>
        The number of <m>n</m>-bit strings of weight <m>k</m> is <m>\binom{n}{k}</m>, so a combination.  But in determining one bit string from another, all that matters is the order in which the <m>k</m> 1's and <m>n-k</m> 0's appear.  So does order matter?  In what sense does it not?
      </p>
    </statement>
    <hint>
      <p>
        Think about what <m>P(n,k)</m> would count when building a bit string.  Why does it make sense to quotient out by <m>k!</m>?
      </p>
    </hint>
  </exploration>

  <exploration>
    <statement>
      <p>
        Write a clear sentence or two saying specifically what we mean when we say <q>order matters</q> to distinguish between combinations and permutations.
      </p>
    </statement>
    <hint>
      <p>
        They key here is to think about the set of outcomes that we are counting.  Ask yourself, the order of what?
      </p>
    </hint>
  </exploration>

  <p>
    Understanding the role of order in distinguishing outcomes often suggests the use of the quotient principle.  You might say we arrive at combinations by counting permutations and <q>modding</q> out by the order.  Each block that corresponds to a single combination is a group of permutations that are only different because of their order.  Let's see if we can apply this to other counting questions.
  </p>

  <activity>
    <introduction>
      <p>
        The ice cream shop is down to only 3 flavors.  If you wanted a 3-scoop cone or a 3-scoop shake, made without repeated flavors, there would only be 6 cones possible and only 1 shake.  But what if you allowed repeated flavors?
      </p>
    </introduction>
    <task>
      <statement>
        <p>
          How many 3-scoop cones are possible?  
        </p>
      </statement>
      <hint>
        <p>
          You should be able to use the multiplicative principle and nothing else here.
        </p>
      </hint>
    </task>
    <task>
      <statement>
        <p>
          How many 3-scoop shakes are there?  Write all of them down.
        </p>
      </statement>
      <hint>
        <p>
          Maybe the flavors are chocolate, vanilla, and strawberry.  Some of the outcomes are <m>ccv</m> and <m>csv</m>, but notice that we would not also include <m>cvc</m> or <m>vcs</m> because in the blender, order doesn't matter.
        </p>
      </hint>
    </task>
    <task>
      <statement>
        <p>
          Why doesn't the quotient principle apply here?  What goes wrong?  
        </p>
        <p>
          List out all 3-scoop cones and form the equivalence classes of shakes to see the issue.
        </p>
      </statement>
    </task>
  </activity>

  <p>
    The previous activity illustrates that you cannot always simply apply the quotient principle to eliminate order mattering.  What we are after in the 3-scoop shakes with possibly repeated flavors is a <term>multiset</term>, which is just like a set only we allow for elements to be in the set multiple times, but we still do not care in what order the elements are listed.  So an example of an <m>4</m>-element multiset of <m>[7]</m> is <m>\{1,3,3,6\}</m>, which is the same multiset as <m>\{1,6,3,3\}</m> but different from the multiset <m>\{1,3,6\}</m> (in particular, this multiset only has three elements).
  </p>

  <p>
    What we tried to do above was to count multisets by first counting sequences with possibly repeated elements, and then divide out by the number of sequences that just differ by the arrangement of a particular multiset.  But this didn't work, because the size of each block was not the same.
  </p>

  <p>
    However, we would still like to be able to count the number of multisets.  How can we do this?  Is it an application of the quotient principle after all?  To start, let's establish some notation.  The number of <m>k</m>-element subsets of <m>[n]</m> was given by <m>n</m> choose <m>k</m> (written <m>\binom{n}{k}</m>), so we will say that the number of <m>k</m>-element <em>multisets</em> of <m>[n]</m> will be <term><m>n</m> multichoose <m>k</m></term>, and write <m>\mchoose{n}{k}</m>.  From what we have seen above, we can say,
    <me>
      \mchoose{n}{k} \ne \frac{n^k}{k!}
    </me>
    despite the obvious allure of this possibility.
  </p>

  <p>
    Our question now is, what <em>should</em> be in the numerator if not <m>n^k</m>?  First let's get more comfortable with thinking of multisets as a model for counting questions.
  </p>

  <activity>
    <introduction>
      <p>
        Explain why each of the following counting problems have an answer in the form <m>\mchoose{n}{k}</m> (say what <m>n</m> and <m>k</m> should be).  That is, show how each of them is counting the number of <m>k</m>-element multisets of <m>[n]</m> (or a different set of size <m>n</m>).
      </p>
    </introduction>
    <task>
      <statement>
        <p>
          If you have an unlimited supply of pennies, nickels, dimes and quarters, how many handfuls of 7 coins can you grab?
        </p>
      </statement>
    </task>
    <task>
      <statement>
        <p>
          You roll 10 regular 6-sided dice (because you enjoy playing two games of Yahtzee at once).  Assuming the dice are indistinguishable, how many different outcomes are possible?
        </p>
      </statement>
    </task>
    <task>
      <statement>
        <p>
          How many functions <m>f:[5] \to [7]</m> are non-decreasing?  For example, one such function is <m>f = \twoline{1 \amp 2 \amp 3 \amp 4 \amp 5}{2 \amp 5 \amp 5 \amp 6 \amp 7}</m>.
        </p>
      </statement>
    </task>
  </activity>

  <activity xml:id="act-distributionintro">
    <introduction>
      <p>
        Explain why each of the following counting problems are also answered in the form <m>\mchoose{n}{k}</m> (and say what <m>n</m> and <m>k</m> are).  You should be able to explain why all of these are equivalent to each other, and then find a bijection from any of them to the set of <m>k</m>-element multisets of <m>[n]</m>.
      </p>
    </introduction>
    <task>
      <statement>
        <p>
          How many non-negative integer solutions are there to the equation <m>x_1 + x_2 + x_3 + x_4 = 10</m>?
        </p>
      </statement>
    </task>
    <task>
      <statement>
        <p>
          How many ways are there to distribute 7 identical cookies to 5 kids? Some kids might not get any cookies, but you should distribute all 7 cookies.
        </p>
      </statement>
    </task>
    <task>
      <statement>
        <p>
          How many ways can you put 10 identical books on the 4 shelves of a bookcase?  Assume each shelf could hold up to 10 books, and that all the books are always shoved all the way to the left (so we are not worried about where the books are on an individual shelf, just which shelf they go on).
        </p>
      </statement>
    </task>
  </activity>

  <p>
    The problems in <xref ref="act-distributionintro"/> are sometimes referred to as <q>distribution problems</q>, since we are asking for the number of ways to distribute some objects to some recipients.   This is a useful model for the other counting techniques we have seen as well.  For example, a permutation <m>P(n,k)</m> gives the number of ways to distribute <m>n</m> distinct objects to <m>k</m> distinct recipients, so that each recipient gets exactly one object.
  </p>

  <p>
    The claim implicit in <xref ref="act-distributionintro"/> is that the number of ways to distribute <m>n</m> identical objects to <m>k</m> distinct recipients (now allowing each recipient to receive any number of objects, including zero) is <m>\mchoose{n}{k}</m>.  If this is the case, then we should be able to think of the set of <m>k</m>-element multisets of <m>[n]</m> as a distribution.
  </p>

  <activity>
    <statement>
      <p>
        Consider <m>3</m>-element multisets of <m>[5]</m>.  One of these is <m>\{1,1,1\}</m>, and another is <m>\{2,4,5\}</m>.  How are these two multisets like distributing three objects among 5 recipients?  What are the objects that you are distributing?
      </p>
    </statement>
  </activity>

  <p>
    Now let's consider a related distribution problem, where in some way, order now matters.  In fact, how is it that saying the distribution problems as in <xref ref="act-distributionintro"/> are ones for which order doesn't matter?  Look back at our standard example of order mattering or not:
  </p>

  <activity>
    <task>
      <statement>
        <p>
          If <m>P(n,k)</m> counts the number of ways to distribute <m>n</m> distinct objects to <m>k</m> distinct recipients in which each recipient receives exactly one object (do you see why this is?), then what distribution does <m>\binom{n}{k}</m> count?  Explain what is playing the role of <q>order mattering</q> in a distribution problem.
        </p>
      </statement>
    </task>
    <task>
      <statement>
        <p>
          We claim that counting the number of ways to distribute <m>n</m> identical books to <m>k</m> distinct shelves is counted by <m>\mchoose{n}{k}</m>, and this is a situation in which order does not matter (since we are counting multisets).  What would the distribution question be if order did matter?  Explain why the answer to that question is NOT <m>n^k</m>. (What distribution does <em>that</em> expression count?)
        </p>
      </statement>
    </task>
  </activity>

  <p>
    Consider the case where the books are distinct instead of identical.  Note also that in the next few activities, the usage of the variables <m>k</m> and <m>n</m> are reversed from above.  As you work through these next activities, think about why that choice was made.
  </p>

  <!-- TODO: sort out n/k usage once and for all -->

  <activity xml:id="bookcase" category="essential and interesting">
      <introduction>
          <p> Suppose we wish to place <m>k</m> distinct books onto the shelves
        of a bookcase with <m>n</m> shelves. For simplicity, assume for now
        that all of the books would fit on any of the shelves. Also, let's
        imagine pushing the books on a shelf as far to the left as we can, so
        that we are only thinking about how the books sit relative to each
        other, not about the exact places where we put the books. Since the
        books are distinct, we can think of the first book, the second book
        and so on. </p>
      </introduction>
      <task>
        <statement>
          <p>How many places are there where we can place the first book? </p>
        </statement>
        <solution>
          <p>
            There are <m>n</m> places where we can place the first book.
          </p>
        </solution>

      </task>

      <task>
        <statement>
          <p>When we place the second book, if we decide to place it on the shelf that already has a book, does it matter if we place it to the left or right of the book that is already there?
          </p>
        </statement>
        <solution>
          <p>
            Yes.
          </p>
        </solution>
      </task>


      <task>
        <statement>
          <p>
            How many places are there where we can place the second book?
          </p>
        </statement>
        <hint>
          <p>
        If you decide to put it on a shelf that already has a book, you have
        two choices of where to put it on that shelf.
          </p>
        </hint>
        <solution>
          <p>
            Once we have placed it, there are <m>n+1</m> places where we can
            place the second book, because on the shelf that has one book, we
            could put the second book to the left or to the right of the book
            already there.
          </p>
        </solution>
      </task>

      <task>
        <statement>
          <p>
            Once we have <m>i-1</m> books placed, if we want to place book <m>i</m>  on a shelf that already has some books, is sliding it in to the left of all the books already there different from placing it to the right of all the books already or between two books already there?

          </p>
        </statement>
        <solution>
          <p>
            All of these are different.
          </p>
        </solution>
      </task>

      <task>
        <statement>
          <p>
            In how many ways may we place the <m>i</m>th book into the bookcase?
          </p>
        </statement>
        <hint>
          <p>
        Among all the places you could put books, on all the shelves, how many are to the immediate left of some book? How many other places are there?
          </p>
        </hint>
        <solution>
          <p>
            Once we have <m>i-1</m> books on the shelves the <m>i</m>th book could go on any shelf to the left of all books there, if any, giving us <m>n</m> places, or it could go to the immediate right of any book already there, giving us another <m>i-1</m> places. Thus there are <m>n+i-1</m> places where we could place book  <m>i</m>.
          </p>
        </solution>
      </task>

      <task>
        <statement>
          <p>
            In how many ways may we place all the books?

          </p>
        </statement>
        <solution>
          <p>
            From this, we can see that the number of ways to place all the books is
            <me>
              \prod_{i=1}^k (n+i-1) = (n)(n+1)(n+2)\cdots(n_k-1).
            </me>
          </p>
        </solution>
      </task>

    </activity>

    <p>
      The assignment of which books go to which shelves of a bookcase is simply a function from the books to the shelves. But a function does not determine which book sits to the left of which others on the shelf, and this information is part of how the books are arranged on the shelves. In other words, the order in which the shelves receive their books matters.  Our function must thus assign an ordered list of books to each shelf. We will call such a function an ordered function.
      More precisely, an <term>ordered function</term><idx><h>ordered function</h></idx><idx><h>function</h><h>ordered</h></idx> from a set <m>S</m> to a set <m>T</m> is a function that assigns an (ordered) list of elements of <m>S</m> to some, but not necessarily all, elements of <m>T</m> in such a way that each element of <m>S</m> appears on one and only one of the lists.<fn>The phrase ordered function is not a standard one, because there is as yet no standard name for the result of an ordered distribution problem.</fn>
    </p>

    <p>
      We often think of functions as a rule that assigns an output to each input.  However, we could equally well specify a function by giving the complete inverse image of each element of the codomain.  That is, to define a (non-ordered) function <m>f:S \to T</m>, we could give the set <m>f\inv(t) = \{s \in S \st f(s) = t\}</m> for each <m>t \in T</m>.  The set of elements sent to <m>t</m> is a <em>set</em> for a function, but for an ordered function, it is a <em>sequence</em>.
    </p>

    <theorem>
      <statement>
        <p>
          The number of ordered functions from a <m>k</m>-element set to
          an <m>n</m>-element set is
          <me>
            \prod_{i=1}^k (n-1+i) = \frac{(n-1+k)!}{(n-1)!} = P(n-1+k, k).
          </me>
        </p>
      </statement>
    </theorem>


    <activity>
      <task>
        <statement>
          <p>
            In some sort of manufacturing mishap, your set of magnetic letters contains only the first 7 letters of the alphabet, and for some reason 5 identical exclamation marks.  How many ways can you arrange all 12 magnets in a single line?  (one such line is BG!AD!!!FEC!).
          </p>
        </statement>
        <solution>
          <p>
            To use the quotient principle, treat the exclamation marks as distinct, and arrange all 12 magnets in <m>12!</m> ways.  Then group lines if the exclamation marks are in the same positions.  There are <m>5!</m> lines in each group, so there are <m>12!/5!</m> groups.
          </p>

          <p>
            Alternatively, you can see this is correct by thinking about picking one of the 12 positions to put the A into, then one of the remaining positions for the B, and so on.  This is <m>P(12,7)</m>, just to put the letters down.  But now you have only one choice as to where to put the exclamation marks.
          </p>
        </solution>
      </task>
      <task>
        <statement>
          <p>
            What does this question have to do with placing <m>7</m> distinct books on <m>6</m> shelves?
          </p>
        </statement>
        <hint>
          <p>
            Note, there are 5 exclamation marks, but 6 shelves.
          </p>
        </hint>
        <solution>
          <p>
            Treat each space separated by exclamation marks as a shelf.  So there is a shelf to the left of the first exclamation mark, a shelf between the first and the second, and so on, including a shelf after the last exclamation mark.
          </p>

          <p>
            Physically, you could think of shelving books as first lining up all the books with bookmarks between groups of books.  You then put everything before the first separator on the first shelf, everything between the first and second separator on the second shelf, and so on.
          </p>
        </solution>
      </task>
      <task>
        <statement>
          <p>
            Oh no! Your 5 year old left the 7 magnetic letters in the oven too long and now they are all identical blobs of plastic.  How many strings of the 12 magnets can you make now?
          </p>
        </statement>
        <hint>
          <p>
            One such string is *!!***!*!*!, which looks a lot like 01100010101.
          </p>
        </hint>
        <solution>
          <p>
            This should be <m>P(12,7)/7! = \binom{12}{7}</m>.  You can see this by realizing that we have really created a bit string of length 12 and weight 7 (thinking of the blobs as the 1's).
          </p>
        </solution>
      </task>
      <task>
        <statement>
          <p>
            What sort of distribution problem does the previous task correspond to?  Write a question about books and shelves that has the same answer.
          </p>
        </statement>
        <solution>
          <p>
            The letters were the books before, and now they still are, but now the books are indistinguishable.  So how many ways can you distribute 7 identical books to 6 shelves?  <m>\binom{12}{7}</m>, which by the way, is also <m>\mchoose{6}{7}</m>.
          </p>
        </solution>
      </task>
    </activity>

    <p>
      AHA!  The previous activity suggests that to count multisets, which is the same as counting distributions of identical objects to distinct recipients, we should apply the quotient principle to ordered functions.
    </p>

    <p>
      What should the equivalence relation be?  Think about bookshelves.  An ordered function is a distribution of distinct books to distinct shelves.  A multiset is a distribution of identical books to distinct shelves.  So we want two ordered functions to be equivalent if their corresponding shelves contain the same number of books (we no longer care what those books are, just how many there are).
    </p>

    <p>
      Now, given any ordered function, how many ordered functions are in its equivalence class?  We can get any other element in the class by permuting the books (but keeping the numbers in each shelf constant).  There are <m>k</m> books, so there are <m>k!</m> ways to permute them.  This is the same for <em>every</em> ordered function, so the equivalence classes all have the same size.
    </p>

    <p>
      Applying the quotient principle, we arrive at the following.
    </p>

    <theorem xml:id="thm-multisetsize">
      <statement>
        <p>
          The number of <m>k</m>-element multisets of <m>[n]</m> is
          <me>
            \mchoose{n}{k} = \frac{P(n-1+k, k)}{k!} = \binom{n-1+k}{k}
          </me>

        </p>
      </statement>
    </theorem>
  <!-- TODO: summarize this and include the usual stars and bars interpretations as an example -->
  <!-- TODO: Add a few review/practice questions? -->
</subsection>

<subsection xml:id="subsec-moredistributions">
  <title>More Distribution Problems</title>

  <p>
    Both multisets and ordered functions allowed some of the recipients to receive nothing (or for some elements of <m>[n]</m> to not be included in the multiset).  What if we didn't want to allow this?
  </p>

  <activity xml:id="bookcaseeveryshelf">
    <statement>
      <p>
        Suppose we wish to place the books in <xref ref="bookcase"/>
        (satisfying the assumptions we made there) so that each shelf gets at
        least one book. Now in how many ways may we place the books? (Hint: how
        can you make sure that each shelf gets at least one book before you start
        the process described in <xref ref="bookcase" />?)
      </p>
    </statement>
    <hint>
      <p>
    How can you make sure that each shelf gets at least one book before you
    start the process described in <xref ref="bookcase" />?
      </p>
    </hint>
    <solution>
      <p>
        Choose <m>n</m> books from the <m>k</m> books in <m>\binom{k}{n}</m>
        ways, and assign them to the <m>n</m> places shelves in <m>n!</m>
        ways, giving us <m>k!/(k-n)!</m> ways to put a book on each shelf.
        Now leaving these books at the far left of each shelf, place the
        remaining books in
        <me>
          \prod_{i=1}^{k-n}
          (n+i-1)=\frac{(n+(k-n)-1)!}{(n-1)!}=\frac{(k-1)!}{(n-1)!}
        </me>
        ways. Thus we have
        <me>
          \frac{k!(k-1)!}{(k-n)!(n-1)!}=k!\binom{k-1}{n-1}
        </me>
        ways to place the books. Of course the right hand side of that
        equation cries out for a combinatorial explanation. Here it is.
        Imagine lining up the <m>k</m> books in a row. Then there are
        <m>k-1</m> places in between them. Choose <m>n-1</m> of these
        places, and slide a piece of paper in there as a divider. Now put
        the books before the first divider on shelf one, and the books after
        divider <m>i</m> on shelf <m>i+1</m>. This gives an arrangement of
        the books on the shelves so that every shelf has a book!
      </p>
    </solution>
</activity>

  <p>
    The previous activity is an example of what we might call an <term>ordered surjection</term>.  Just like we did with ordered functions, we can apply the quotient principle to count distributions where the objects being distributed are no longer distinct.
  </p>


<exploration category="essential for this or the next section">
  <statement>
    <p>
      In how many ways may we put <m>k</m> identical books onto <m>n</m>
      shelves if each shelf must get at least one book?
    </p>
  </statement>
  <hint>
    <p>
  We already know how to place <m>k</m> distinct books onto <m>n</m> distinct shelves so
  that each shelf gets at least one. Suppose we replace the distinct books
  with identical ones. If we permute the distinct books before replacement,
  does that affect the final outcome? There are other ways to solve this problem.
    </p>
  </hint>
  <solution>
    <p>
      In <xref ref="bookcaseeveryshelf">problem</xref> we showed that with
      <m>k</m> distinct books we could place the books in
      <m>k!\binom{k-1}{n-1}</m> ways. We can partition these arrangements of
      distinct books into blocks, where each block consists of all
      arrangements that we get just by permuting the books among themselves.
      Thus each block has <m>k!</m> arrangements in it, and each arrangement
      corresponds to an arrangement of identical books. Thus there are <m>\binom{k-1}{n-1}</m> ways to arrange identical books.
    </p>
  </solution>
</exploration>

<!-- TODO: add example/activity introducing compositions?  Ask them to list some out! -->

<example xml:id="compositionagian" category="essential for this or the next section">
  <statement>
    <p>
      A <term>composition</term> of the integer <m>k</m> into <m>n</m> parts is a list of <m>n</m> positive integers that add to <m>k</m>.  How many compositions are there of an integer <m>k</m> into <m>n</m> parts?
    </p>
  </statement>
  <!-- <hint>
    <p>
  Do you see a relationship between compositions and something else we have
  counted already?
    </p>
  </hint> -->
  <solution>
    <p>There is a bijection between compositions of <m>k</m> into <m>n</m> parts and arrangements of <m>k</m> identical books on <m>n</m> shelves so that each shelf gets a book. Namely, the number of books on shelf <m>i</m> is the <m>i</m>th element of the list. Thus the number of compositions of <m>k</m> into <m>n</m> parts is <m>\binom{k-1}{n-1}</m>.
    </p>
  </solution>
</example>

<example category="interesting">
  <statement>
    <p>The answer in <xref ref="compositionagian"/> can be expressed as a binomial coefficient. This means it should be possible to interpret a composition as a subset of some set. Find a bijection between compositions of <m>k</m> into <m>n</m> parts and certain subsets of some set.  Explain explicitly how to get the composition from the subset and the subset from the composition.
    </p>
  </statement>

  <solution>
    <p>If we line up <m>k</m> identical books, there are <m>k-1</m> places in between two books. If we choose <m>n-1</m> of these places and slip dividers into those places, then we have a first clump of books, a second clump of books, and so on. The <m>i</m>th element of our list is the number of books in the <m>i</m>th clump. Clearly using books is irrelevant; we could line up any <m>k</m> identical objects and make the same argument. Our bijection is between compositions and <m>(n-1)</m>-element subsets of the set of <m>k-1</m> spaces between our objects.
    </p>
  </solution>
</example>

<exploration category="essential for this or the next section">
  <statement>
    <p>
      Explain the connection between compositions of <m>k</m> into <m>n</m>
      parts and the problem of distributing <m>k</m> identical objects to
      <m>n</m> recipients so that each recipient gets at least one.
    </p>
  </statement>
  <solution>
    <p>
      Since the recipients are distinct, we can think of them as a first
      recipient, a second, and so on. Given a composition of <m>k</m> into
      <m>n</m> parts, let the <m>i</m>th element of the list be the number
      of objects given to recipient number <m>i</m>.
    </p>
  </solution>
</exploration>

  <p>
    So far, we have only considered distribution problems in which the recipients are distinct.  There are plenty of situations where we would want to consider recipients identical.  For example, a problem we will take up in <xref ref="ch_advanced"/> is how many ways we can partition an integer.  For example, we could partition 5 as <m>4+1</m> or <m>3+1+1</m>, but we would not want to also count <m>1+4</m> or <m>1+3+1</m> (doing so would be creating a <em>composition</em>, which we have already considered).  We can think of the integer partition problem as distributing the 5 units that make up 5 into some number of identical bins.
  </p>

  <p>
    Here is another example, which we already have the tools to address.
  </p>

  <exploration xml:id="brokenpermutation" category="essential for this or the next section, and interesting">
    <statement>
      <p>
        In how many ways may we stack <m>k</m> distinct books into <m>n</m> identical boxes so that there is a stack in every box? There are two distinct ways to answer this question.  Find them both.
      </p>
    </statement>
    <hint>
        <p>Imagine taking a stack of <m>k</m> books, and breaking it up into stacks to put into the boxes in the same order they were originally stacked. If you are going to use <m>n</m> boxes, in how many places will you have to break the stack up into smaller stacks, and how many ways can you do this?
        </p>
    </hint>
    <hint>
        <p>
            How many different bookcase arrangements correspond to the same way of stacking <m>k</m> books into <m>n</m> boxes so that each box has at least one book?
        </p>
    </hint>
    <solution>
      <p>
        We can make a list of the <m>k</m> distinct books in <m>k!</m> ways. Then we have to choose <m>n-1</m> of the <m>k-1</m> places between the lists as the places where we will break the list. However the order in which we list the boxes is irrelevant, so we have equivalence classes of <m>n!</m> arrangements for each way of putting the books into boxes. Thus we can put the books in boxes in <m>k!\binom{k-1}{n-1}/n!</m> ways.
      </p>

      <p>
        Alternately, we can take the number of ways to put <m>k</m> books onto <m>n</m> bookshelves so that each shelf gets at least one, and then divide by the number of shelves factorial. That gives us <m>k!\binom{k-1}{n-1}/n!</m> ways to arrange the books.
      </p>
    </solution>
  </exploration>

  <p>
    We can think of stacking books into identical boxes as partitioning the books and then ordering the blocks of the partition. This turns out not to be a useful computational way of visualizing the problem because the number of ways to order the books in the various stacks depends on the sizes of the stacks and not just the number of stacks. However this way of thinking actually led to the first hint in <xref ref="brokenpermutation" />. Instead of dividing a set up into non-overlapping parts, we may think of dividing a <em>permutation</em> (thought of as a list) of our <m>k</m> objects up into <m>n</m> ordered blocks. We will say that a set of ordered lists of elements of a set <m>S</m> is a <term>broken permutation</term>
    <idx><h>broken permutation</h></idx> <idx><h>permutation</h><h>broken</h></idx>
    of <m>S</m> if each element of <m>S</m> is in one and only one of these lists.<fn>The phrase broken permutation is not standard, because there is no standard name for the solution to this kind  of distribution problem.</fn> The number of broken permutations of a <m>k</m>-element set with <m>n</m> blocks is denoted by <m>L(k,n)</m>. The number <m>L(k,n)</m> is called a <term>Lah Number</term> and, from our solution to <xref ref="brokenpermutation"/>, is equal to <m>k!\binom{k-1}{n-1}/n!</m>.<idx><h>Lah number</h></idx>
  </p>

  <p>
    The Lah numbers are the solution to the question <q>In how many ways may we
    distribute <m>k</m> distinct objects to <m>n</m> identical recipients if order
    matters and each recipient must get at least one?</q>
  </p>


</subsection>

 <!-- <xi:include href="exercises/basic-quotient.ptx"/> -->

</section>
